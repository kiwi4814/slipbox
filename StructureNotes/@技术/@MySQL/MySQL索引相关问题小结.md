### 索引基础知识

1. 索引的数据结构是什么？

   对于InnoDB引擎来说，使用B+树索引模型，每个索引对应一颗B+树。

   - **主键索引**，也叫聚簇索引（clustered index），叶子节点存储的是整行数据。

   - **非主键索引**，也叫二级索引（secondary index），叶子节点存储的是主键的值。如果根据二级索引查询，会先根据二级索引找到主键，然后再根据主键查询主键索引找到数据，这个过程被称为回表。

   - **联合索引**：按照第一个字段排序，第一个字段重复的时候按照第二个字段排序，以此类推...

2. 索引的一些原则

   **覆盖索引**：如果要查询的字段已经在某个索引树上了，可以避免掉回表的过程，是常见的性能优化的手段

   **最左前缀原则**：MYSQL做词法分析语法分析的时候是通过建立最左子树来建立语法树的，解析的过程也是从左到右所以遵循最左前缀的原则。这里不仅仅指的是联合索引，也可以是字符串索引的最左边的N个字符，比如 `like 'aaa%'`这种形式。

   **索引下推**：MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

   

3. 普通索引和唯一索引

   不推荐使用过长的ID作为主键（非主键索引也会存储主键，浪费空间）

   - （1）查询 等于 的情况：几乎没有区别，MySQL读取数据以页的形式进行读取，除非刚好在分界点
   - （2）更新：唯一索引因为需要校验唯一性约束，是无法使用change buffer的，所以只有普通索引能用。
   - 对于写多读少的业务来说，尽量使用普通索引，这样能减少随机访问IO的次数，提升效率。

4. MySQL选错索引：

   MySQL选择索引会根据统计信息来选择使用哪个索引，所以会出现索引用错的情况，这时候可以使用force index来强行指定索引。

5. 字符串字段加索引的一些原则：

   - 尽量选择区分度高的列作为索引,区分度的公式是`count(distinct col)/count(*)`，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。
   - 如果只有等值查询的需求，可以适当的使用一些小技巧。比如倒序存储（身份证）、增加hash字段（crc32）来减少索引的大小。

   

### count(*)

1. 对于没有任何查询条件的count(*)，MyISAM引擎直接从事先在磁盘存好的表行数中读取即可，InnoDB则是累计计数，是因为由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的。
2. MySQL对于count(*)有专门的优化，主要体现在MySQL会查找最小的那颗索引树来遍历取得行数，因为普通索引树比主键索引树小很多。
3. show table status 命令虽然返回很快，但是不准确，因为这个值是通过采样来估算的，实际误差可能达到40%~50%。
4. 从查询效率上来讲，count(字段)<count(主键 id)<count(1)≈count(*)



### order by

1. 全字段排序：MySQL对于每个线程都会分配一块内存sort_buffer专门用于排序，全字段排序会把查询结果的字段放进这块内存区域，然后排序并返回结果；
2. rowid排序：如果单条数据过大，则只会取排序字段和对应ID，但也会多访问一次主键索引。
3. 并不是所有排序都需要用到sort_buffer，如果排序的字段本身就是有序的，那么就不需要了。



### join

- 关于驱动表

  - 当使用left join时，左表是驱动表，右表是被驱动表
  - 当使用right join时，右表时驱动表，左表是驱动表
  - 当使用join时，mysql会选择数据量比较小的表作为驱动表，大表作为被驱动表

- *NLJ算法*：Index Nested-Loop Join 

  - 假如被驱动表能用上索引，这时候的流程为：驱动表（行数为N）全表扫描，然后拿出join的字段，去被驱动表（行数为M）查询，由于这时候是可以用上被驱动表的索引的，需要扫描的总行数为`N + N*2*log2M`，所以N的行数越小越好，即用小表作为驱动表会更好。

- *BLJ算法*：Block Nested-Loop Join

  - 假设被驱动表没能用上索引，会将驱动表的数据**分段**写入join_buffer中，然后扫描被驱动表。假设驱动表行数为N，被驱动表行数为M，由于join_buffer的大小限制，所以N需要分成K端，也就是λ*N，这时候需要扫描的总行数为`N+λ*N*M`，由于λ是介于0和1之间的，所以仍然是N对结果影响更大，仍然是用小表作为驱动表效果更好。
  - 此外，在上面的公式中，λ的值越小越好，也就是分的段数越小越好，即join_buffer_size越大越好，这就是为什么，你可能会看到一些建议告诉你，如果你的 join 语句很慢，就把 join_buffer_size 改大。
  - 在决定哪个表做驱动表的时候，应该是**两个表按照各自的条件过滤**，过滤完成之后，**计算参与 join 的各个字段的总数据量**，数据量小的那个表，就是“小表”，应该作为驱动表。

  

### 知识要点

用于提高读写效率的数据结构有很多，常见的有：哈希表、有序数组和搜索树。

**哈希表**：哈希数组+链表，但由于数据无序，做区间查询很慢，适合等值查询的场景（Memcached及其他一些NoSQL引擎）

**有序数组**：按照数据大小的方式保存，查找数据使用二分法，时间复杂度是O(log(N))；但是更新数据成本太高。所以适合静态存储引擎，比如不会再更新的历史数据。

**二叉搜索树**



索引相关篇章：

基础知识：04、05

应用：9、10、11

order by：14、16

join：34、35





### change buffer

更新数据时会先把数据放入change buffer，在下次访问/定期/数据库关闭的时候都会执行merge操作，将数据应用到原数据页。



change buffer 的大小，可以通过参数 innodb_change_buffer_max_size 来动态设置。这个参数设置为 50 的时候，表示 change buffer 的大小最多只能占用 buffer pool 的 50%。





