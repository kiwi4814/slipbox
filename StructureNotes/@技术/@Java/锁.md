#### 一、悲观锁、乐观锁

线程要不要锁住同步资源？

- **悲观锁**认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。
- **乐观锁**认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。

#### 二、阻塞、自旋锁、适应性自旋锁

锁住同步资源失败的时候，线程要不要阻塞？



如果阻塞的话，会带来CPU切换的额外消耗，在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。所以我们让线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。



自旋占用了处理器时间，所以一定要设置上限（默认是10次，可以使用-XX:PreBlockSpin来更改）。它的实现原理也是CAS。

#### 三、无锁、偏向锁、轻量级锁、重量级锁

多个现场竞争同步资源的流程细节：

- **无锁**：不锁住资源，多个线程中只有一个能修改资源成功，其他线程会重试
- **偏向锁**：同一个线程执行同步资源时自动获取资源
- **轻量级锁**：多个现场竞争同步资源时，没有获取资源的线程自旋等待锁释放
- **重量级锁**：多个现场竞争同步资源时，没有获取资源的线程阻塞等待唤醒


#### 四、公平锁、非公平锁

多个线程竞争时要不要排队？


#### 五、可重入锁、非可重入锁

一个线程中的多个流程能不能获取同一把锁？


#### 六、共享锁、排他锁

多个线程能不能共享一把锁？

