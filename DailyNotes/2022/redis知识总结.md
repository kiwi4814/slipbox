#### 1. Redis到底是多线程还是单线程？

Redis 6.0之前的版本的单线程指的是对其网络I/O和键值对的读写是由一个线程完成的，而对于Redis为什么使用单线程，官方的解释如下：

> It's not very frequent that CPU becomes your bottleneck with Redis, as usually Redis is either memory or network bound.

大概就是说，由于redis是基于内存和网络的，所以引起redis性能瓶颈的通常不是CPU，也就没必要采用多线程了。



当然了，它的持久化、集群的数据同步等，其实是由额外的线程来完成的，因为这并不影响整个网络模型是单线程的。



而Redis 6.0之后引入的多线程， 只是针对网络模型，加入多线程I/O来处理网络I/O的性能瓶颈，此时虽然I/O读写是多线程的，但是执行命令仍然是单线程的。



#### 2. Redis单线程为什么还能这么快？

主要基于以下几点：

- 纯内存操作，一条命令在内存的操作时间极短
- 单线程操作没有线程切换开销
- 基于I/O多路复用机制提升Redis的I/O利用率，非阻塞 I/O 部实现采用 epoll，采用了 epoll+自己实现的简单的事件框架
- 高效的数据结构，全局哈希表以及多种高效数据结构，比如跳表、压缩列表以及链表等



#### 3. Redis底层数据是如何用跳表来存储的？

关于redis底层的数据结构，专门用一篇文章去讲。



#### 4. Redis Key 过期了为什么内存没释放？

这里要注意的是Set命令如果不设置过期时间，那么这个key的过期时间为-1，不会过期。



Redis对于过期Key的处理一般有两种策略：惰性删除和定时删除。

所谓的惰性删除，就是下次读写的时候会进行删除，而定时删除，就是指的redis每隔一段时间（默认100ms）就会删除掉一部分已过期的key，注意这里只是一部分而不是全部，所以偶尔会出现你查找的那个key没有及时删除的情况。



#### 5. Redis key没有设置过期时间为什么被redis主动删除了？



当 redis 内存使用超过配置的限定值（maxmemory）时，会触发主动清理策略，这时候redis会按照一定的策略去清理一定的数据，这几种内存淘汰策略可以在配置文件中进行配置（maxmemory-policy），8种类型分类列出分别是：



**第一类，根据过期时间的淘汰策略**

- `volatile-ttl`: 针对设置了过期时间的键值对，根据过期时间的先后进行删除
- `volatile-random`: 在设置了过期时间的键值对种随机进行删除
- `volatile-lru`: 使用LRU算法筛选设置了过期时间的键值对
- `volatile-lfu`: 使用LFU算法筛选设置了过期时间的键值对

**第二类：所有数据范围内的淘汰策略**

- `allkeys-random`: 从所有键值对种随机挑选数据进行删除
- `allkeys-lru`: 使用LRU算法在所有数据种进行筛选并删除
- `allkeys-lfu`: 使用LFU算法在所有数据种进行筛选并删除

**第三类：不淘汰**

- `noeviction`: 不淘汰任何数据，有新的请求时直接返回错误

#### 6. Redis淘汰算法LRU和LFU的区别

关于LRU和LFU算法：

- `LRU`（Least Recently Used，最近最少使用）：如果一个数据最近刚刚被访问，那么他就算是热点数据，还会被再次访问。按照这种算法，会删除掉访问时间离现在最久的数据。
- `LFU`（Least Frequently Used，最不常用）：与 LRU 算法只是在淘汰策略上有所不同，LRU 倾向于保留最近有使用的数据，而 LFU 倾向于保留使用频率较高的数据。如果我们项目中有一些热点缓存数据需要频繁的访问，可以考虑使用LFU算法。



#### 7. Redis什么情况下会阻塞？

**内在原因包括：**

- 不合理的使用API或者数据结构

  比如一次存几十上百M的数据、或者对包含了上万个元素的hash结构执行hgetall命令，Redis原生提供慢查询统计功能，执行slowlog get{n}命令可以获取最近 的n条慢查询命令，默认对于执行超过10毫秒的命令都会记录到一个定长队 列中，线上实例建议设置为1毫秒便于及时发现毫秒级以上的命令。解决方案有修改为低算法度的命令，禁用keys、sort命令等。

- CPU饱和

  指Redis把单核CPU使用率跑到接近100%，可以使用top命令查看对应redis进程的CPU使用率

- 持久化阻塞

  对于开启了持久化的redis节点，可以排查持久化阻塞。主要包括：fork阻塞、AOF刷盘阻塞、HugePage写操作阻塞。

**外在原因包括：**

- CPU竞争

  由于Redis是典型的CPU密集型应用，不建议和其他多核CPU密集型服务部署到一起

- 内存交换

  内存交换（swap）对于Redis来说是非常致命的，Redis保证高性能的一 个重要前提是所有的数据在内存中。如果操作系统把Redis使用的部分内存 换出到硬盘，由于内存与硬盘读写速度差几个数量级，会导致发生交换后的 Redis性能急剧下降。

- 网络问题

	网络问题经常是引起Redis阻塞的问题点。常见的网络问题主要有：连 接拒绝、网络延迟、网卡软中断等。



**总结**：

（1）客户端最先感知阻塞等Redis超时行为，加入日志监控报警工具可快速定位阻塞问题，同时需要对Redis进程和机器做全面监控。

（2）阻塞的内在原因：确认主线程是否存在阻塞，检查慢查询等信息， 发现不合理使用API或数据结构的情况，如keys、sort、hgetall等。关注CPU使用率防止单核跑满。当硬盘IO资源紧张时，AOF追加也会阻塞主线程。

（3）阻塞的外在原因：从CPU竞争、内存交换、网络问题等方面入手排查是否因为系统层面问题引起阻塞。

#### 8. Redis主从、哨兵、集群架构优缺点比较

##### 1）主从模式

主要方式：采用读写分离的方式，主库和从库都可以进行读操作，而对于写操作，首先在主库执行，然后主库将写操作同步给从库。

存在的限制：一旦主库挂了，需要人为干预

##### 2）哨兵集群

主要方式：客户端先访问哨兵来得到地址，然后再通过这个地址进行读写操作。哨兵集群负责在master节点挂掉的期间选举新的节点。

##### 3）集群架构

主要方式：数据分片存储在不同的节点，通过hash槽的形式来确定数据存储到哪个分片。这种模式不再需要哨兵集群了，因为slave节点可以通过其他master节点的选举来当选主节点。





#### Redis缓存问题

#### Redis分布式锁

#### Redis pub/sub





#### 





